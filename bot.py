import telebot
import re
import threading
import time
import json
from telebot.types import InlineKeyboardMarkup, InlineKeyboardButton
from datetime import datetime
from p import check_card  # Make sure check_card(cc_line) is in p.py

# BOT Configuration
BOT_TOKEN = '7881588527:AAHApss63yicaGs0NLA'   
ADMIN_ID = 5248903529  # Replace with your Telegram user ID (int)

bot = telebot.TeleBot(BOT_TOKEN)

AUTHORIZED_USERS = {}

# ---------------- Helper Functions ---------------- #

def load_auth():
    try:
        with open("authorized.json", "r") as f:
            return json.load(f)
    except:
        return {}

def save_auth(data):
    with open("authorized.json", "w") as f:
        json.dump(data, f)

def is_authorized(chat_id):
    if chat_id == ADMIN_ID:
        return True
    if str(chat_id) in AUTHORIZED_USERS:
        expiry = AUTHORIZED_USERS[str(chat_id)]
        if expiry == "forever":
            return True
        if time.time() < expiry:
            return True
        else:
            del AUTHORIZED_USERS[str(chat_id)]
            save_auth(AUTHORIZED_USERS)
    return False

def normalize_card(text):
    """
    Normalize credit card from any format to cc|mm|yy|cvv
    Similar to PHP normalize_card function
    """
    if not text:
        return None

    # Replace newlines and slashes with spaces
    text = text.replace('\n', ' ').replace('/', ' ')

    # Find all numbers in the text
    numbers = re.findall(r'\d+', text)

    cc = mm = yy = cvv = ''

    for part in numbers:
        if len(part) == 16:  # Credit card number
            cc = part
        elif len(part) == 4 and part.startswith('20'):  # 4-digit year starting with 20
            yy = part
        elif len(part) == 2 and int(part) <= 12 and mm == '':  # Month (2 digits <= 12)
            mm = part
        elif len(part) == 2 and not part.startswith('20') and yy == '':  # 2-digit year
            yy = '20' + part
        elif len(part) in [3, 4] and cvv == '':  # CVV (3-4 digits)
            cvv = part

    # Check if we have all required parts
    if cc and mm and yy and cvv:
        return f"{cc}|{mm}|{yy}|{cvv}"

    return None

AUTHORIZED_USERS = load_auth()

# ---------------- Bot Commands ---------------- #

@bot.message_handler(commands=['start'])
def start_handler(msg):
    bot.reply_to(msg, """âœ¦â”â”â”[ á´¡á´‡ÊŸá´„á´á´á´‡ á´›á´ á´„á´„ á´„Êœá´‡á´„á´‹á´‡Ê€ Ê™á´á´› ]â”â”â”âœ¦

âŸ¡ á´É´ÊŸÊ á´€á´œá´›Êœá´Ê€Éªá´¢á´‡á´… á´á´‡á´Ê™á´‡Ê€êœ± á´„á´€É´ á´œêœ±á´‡ á´›ÊœÉªêœ± Ê™á´á´›
âŸ¡ á´œêœ±á´‡ /b3 á´›á´ á´„Êœá´‡á´„á´‹ êœ±ÉªÉ´É¢ÊŸá´‡ á´„á´€Ê€á´…
âŸ¡ êœ°á´Ê€ á´á´€êœ±êœ± á´„Êœá´‡á´„á´‹, Ê€á´‡á´˜ÊŸÊ á´„á´„ êœ°ÉªÊŸá´‡ á´¡Éªá´›Êœ /mb3

Ê™á´á´› á´˜á´á´¡á´‡Ê€á´‡á´… Ê™Ê ğ—•ğ—¨ğ—¡ğ—¡ğ—¬ ğŸš€""")

@bot.message_handler(commands=['auth'])
def authorize_user(msg):
    if msg.from_user.id != ADMIN_ID:
        return
    try:
        parts = msg.text.split()
        if len(parts) < 2:
            return bot.reply_to(msg, "âŒ Usage: /auth <user_id> [days]")
        user = parts[1]
        days = int(parts[2]) if len(parts) > 2 else None

        if user.startswith('@'):
            return bot.reply_to(msg, "âŒ Use numeric Telegram ID, not @username.")

        uid = int(user)
        expiry = "forever" if not days else time.time() + (days * 86400)
        AUTHORIZED_USERS[str(uid)] = expiry
        save_auth(AUTHORIZED_USERS)

        msg_text = f"âœ… Authorized {uid} for {days} days." if days else f"âœ… Authorized {uid} forever."
        bot.reply_to(msg, msg_text)
    except Exception as e:
        bot.reply_to(msg, f"âŒ Error: {e}")

@bot.message_handler(commands=['rm'])
def remove_auth(msg):
    if msg.from_user.id != ADMIN_ID:
        return
    try:
        parts = msg.text.split()
        if len(parts) < 2:
            return bot.reply_to(msg, "âŒ Usage: /rm <user_id>")
        uid = int(parts[1])
        if str(uid) in AUTHORIZED_USERS:
            del AUTHORIZED_USERS[str(uid)]
            save_auth(AUTHORIZED_USERS)
            bot.reply_to(msg, f"âœ… Removed {uid} from authorized users.")
        else:
            bot.reply_to(msg, "âŒ User is not authorized.")
    except Exception as e:
        bot.reply_to(msg, f"âŒ Error: {e}")

@bot.message_handler(commands=['b3'])
def b3_handler(msg):
    if not is_authorized(msg.from_user.id):
        return bot.reply_to(msg, """âœ¦â”â”â”[  á´€á´„á´„á´‡êœ±êœ± á´…á´‡É´Éªá´‡á´… ]â”â”â”âœ¦

âŸ¡ Êá´á´œ á´€Ê€á´‡ É´á´á´› á´€á´œá´›Êœá´Ê€Éªá´¢á´‡á´… á´›á´ á´œêœ±á´‡ á´›ÊœÉªêœ± Ê™á´á´›
âŸ¡ á´É´ÊŸÊ á´€á´œá´›Êœá´Ê€Éªá´¢á´‡á´… á´á´‡á´Ê™á´‡Ê€êœ± á´œêœ±á´‡ á´›ÊœÉªêœ± Ê™á´á´›

âœ§ á´˜ÊŸá´‡á´€êœ±á´‡ á´„á´É´á´›á´€á´„á´› á´€á´…á´ÉªÉ´ êœ°á´Ê€ á´€á´œá´›Êœá´Ê€Éªá´¢á´€á´›Éªá´É´
âœ§ ğ—•ğ—¨ğ—¡ğ—¡ğ—¬ ğŸš€""")

    cc = None

    # Check if user replied to a message
    if msg.reply_to_message:
        # Extract CC from replied message
        replied_text = msg.reply_to_message.text or ""
        cc = normalize_card(replied_text)

        if not cc:
            return bot.reply_to(msg, "âœ¦â”â”â”[ ÉªÉ´á´ á´€ÊŸÉªá´… êœ°á´Ê€á´á´€á´› ]â”â”â”âœ¦\n\n"
"âŸ¡ á´„á´á´œÊŸá´…É´'á´› á´‡xá´›Ê€á´€á´„á´› á´ á´€ÊŸÉªá´… á´„á´€Ê€á´… ÉªÉ´êœ°á´ êœ°Ê€á´á´ Ê€á´‡á´˜ÊŸÉªá´‡á´… á´á´‡êœ±êœ±á´€É¢á´‡\n\n"
"á´„á´Ê€Ê€á´‡á´„á´› êœ°á´Ê€á´á´€á´›\n\n"
"`/b3 4556737586899855|12|2026|123`\n\n"
"âœ§ á´„á´É´á´›á´€á´„á´› á´€á´…á´ÉªÉ´ Éªêœ° Êá´á´œ É´á´‡á´‡á´… Êœá´‡ÊŸá´˜")
    else:
        # Check if CC is provided as argument
        args = msg.text.split(None, 1)
        if len(args) < 2:
            return bot.reply_to(msg, "âœ¦â”â”â”[ ÉªÉ´á´ á´€ÊŸÉªá´… êœ°á´Ê€á´á´€á´› ]â”â”â”âœ¦\n\n"
"âŸ¡ á´˜ÊŸá´‡á´€êœ±á´‡ á´œêœ±á´‡ á´›Êœá´‡ á´„á´Ê€Ê€á´‡á´„á´› êœ°á´Ê€á´á´€á´› á´›á´ á´„Êœá´‡á´„á´‹ á´„á´€Ê€á´…êœ±\n\n"
"á´„á´Ê€Ê€á´‡á´„á´› êœ°á´Ê€á´á´€á´›\n\n"
"`/b3 4556737586899855|12|2026|123`\n\n"
"á´Ê€ Ê€á´‡á´˜ÊŸÊ á´›á´ á´€ á´á´‡êœ±êœ±á´€É¢á´‡ á´„á´É´á´›á´€ÉªÉ´ÉªÉ´É¢ á´„á´„ á´¡Éªá´›Êœ `/b3`\n\n"
"âœ§ á´„á´É´á´›á´€á´„á´› á´€á´…á´ÉªÉ´ Éªêœ° Êá´á´œ É´á´‡á´‡á´… Êœá´‡ÊŸá´˜")

        # Try to normalize the provided CC
        raw_input = args[1]

        # Check if it's already in valid format
        if re.match(r'^\d{16}\|\d{2}\|\d{2,4}\|\d{3,4}$', raw_input):
            cc = raw_input
        else:
            # Try to normalize the card
            cc = normalize_card(raw_input)

            # If normalization failed, use the original input
            if not cc:
                cc = raw_input

    processing = bot.reply_to(msg, "âœ¦â”â”â”[  á´˜Ê€á´á´„á´‡êœ±êœ±ÉªÉ´É¢ ]â”â”â”âœ¦\n\n"
"âŸ¡ Êá´á´œÊ€ á´„á´€Ê€á´… Éªêœ± Ê™á´‡ÉªÉ´É¢ á´„Êœá´‡á´„á´‹...\n"
"âŸ¡ á´˜ÊŸá´‡á´€êœ±á´‡ á´¡á´€Éªá´› á´€ êœ°á´‡á´¡ êœ±á´‡á´„á´É´á´…êœ±\n\n"
"âœ§ á´…á´ É´á´á´› êœ±á´˜á´€á´ á´Ê€ Ê€á´‡êœ±á´œÊ™á´Éªá´› âœ§")

    def check_and_reply():
        try:
            result = check_card(cc)  # This function must be in your p.py
            bot.edit_message_text(result, msg.chat.id, processing.message_id, parse_mode='HTML')
        except Exception as e:
            bot.edit_message_text(f"âŒ Error: {str(e)}", msg.chat.id, processing.message_id)

    threading.Thread(target=check_and_reply).start()

# ------------- NEW: Mass check up to 20 cards /mb3 -------------

@bot.message_handler(commands=['mb3'])
def mb3_handler(msg):
    if not is_authorized(msg.from_user.id):
        return bot.reply_to(msg, "Access denied.")

    if not msg.reply_to_message:
        return bot.reply_to(msg, "Reply to a text or .txt file containing cards (max 20 lines).")

    # Get text from replied message or file
    reply = msg.reply_to_message
    if reply.document:
        file_info = bot.get_file(reply.document.file_id)
        downloaded_file = bot.download_file(file_info.file_path)
        text = downloaded_file.decode('utf-8', errors='ignore')
    else:
        text = reply.text or ""
        if not text.strip():
            return bot.reply_to(msg, "âŒ Empty text message.")

    # Extract up to 20 cards
    cc_lines = []
    for line in text.splitlines():
        line = line.strip()
        if not line: continue
        norm = normalize_card(line)
        if norm: cc_lines.append(norm)
        if len(cc_lines) >= 20: break

    if not cc_lines:
        return bot.reply_to(msg, "No valid cards found.")

    bot.reply_to(msg, f"Checking {len(cc_lines)} cards. Please wait...")

    def check_all():
        for cc in cc_lines:
            try:
                result = check_card(cc)
                bot.send_message(msg.chat.id, result, parse_mode='HTML')
                time.sleep(2)
            except Exception as e:
                bot.send_message(msg.chat.id, f"âŒ Error: {str(e)}")

    threading.Thread(target=check_all).start()

# ---------------- Start Bot ---------------- #
bot.infinity_polling()
